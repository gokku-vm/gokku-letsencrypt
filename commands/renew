#!/bin/bash

# Source Gokku helper functions
if [ -f "/opt/gokku/scripts/plugin-helpers.sh" ]; then
    # shellcheck disable=SC1091
    source /opt/gokku/scripts/plugin-helpers.sh
fi

if [ -f "/opt/gokku/letsencrypt/lib/functions.sh" ]; then
    # shellcheck disable=SC1091
    source /opt/gokku/letsencrypt/lib/functions.sh
fi

SERVICE_FILTER="$1"

PLUGIN_DIR="/opt/gokku/plugins/letsencrypt"
CERTS_DIR="$PLUGIN_DIR/certs"
LOGS_DIR="$PLUGIN_DIR/logs"
SERVICES_ROOT="/opt/gokku/services"

if [ -n "$SERVICE_FILTER" ]; then
    echo "-----> Renewing Let's Encrypt certificates (service filter: $SERVICE_FILTER)"
else
    echo "-----> Renewing Let's Encrypt certificates"
fi

# Ensure plugin installation
if [ ! -d "$PLUGIN_DIR" ]; then
    echo "-----> Let's Encrypt plugin not installed"
    echo "       Run 'gokku letsencrypt:install' first"
    exit 1
fi

# Ensure there are certificates to renew
if [ ! -d "$CERTS_DIR" ] || ! compgen -G "$CERTS_DIR/*" > /dev/null; then
    echo "-----> No certificates found"
    echo "       Run 'gokku letsencrypt:create <domain> [email]' to issue certificates"
    exit 0
fi

update_symlinks_for_service() {
    local service="$1"
    local service_dir="$SERVICES_ROOT/$service"
    local service_ssl_dir="$service_dir/ssl"

    if [ ! -d "$service_dir" ]; then
        echo "       Service '$service' directory not found, skipping"
        return
    fi

    mkdir -p "$service_ssl_dir"

    echo "       Updating SSL symlinks for service: $service"
    while IFS= read -r -d '' domain_dir; do
        local domain
        local fullchain
        local privkey

        domain=$(basename "$domain_dir")
        fullchain="$domain_dir/fullchain.pem"
        privkey="$domain_dir/privkey.pem"

        if [ -f "$fullchain" ] && [ -f "$privkey" ]; then
            ln -sf "$fullchain" "$service_ssl_dir/$domain.crt"
            ln -sf "$privkey" "$service_ssl_dir/$domain.key"
            echo "         Linked domain: $domain"
        fi
    done < <(find "$CERTS_DIR" -mindepth 1 -maxdepth 1 -type d -print0)
}

services_to_update=()
add_service_to_update() {
    local candidate="$1"
    local existing
    [ -z "$candidate" ] && return
    for existing in "${services_to_update[@]}"; do
        if [ "$existing" = "$candidate" ]; then
            return
        fi
    done
    services_to_update+=("$candidate")
}

if [ -n "$SERVICE_FILTER" ]; then
    add_service_to_update "$SERVICE_FILTER"
fi

if [ ${#services_to_update[@]} -eq 0 ]; then
    candidate_ssl_dirs=()
    if command -v list_ssl_dirs >/dev/null 2>&1; then
        mapfile -t candidate_ssl_dirs < <(list_ssl_dirs)
    elif [ -d "$SERVICES_ROOT" ]; then
        while IFS= read -r -d '' ssl_dir; do
            candidate_ssl_dirs+=("$ssl_dir")
        done < <(find "$SERVICES_ROOT" -mindepth 2 -maxdepth 2 -type d -name ssl -print0 2>/dev/null)
    fi

    if [ ${#candidate_ssl_dirs[@]} -gt 0 ]; then
        for ssl_dir in "${candidate_ssl_dirs[@]}"; do
            service_name=$(basename "$(dirname "$ssl_dir")")
            if compgen -G "$ssl_dir"/*.crt > /dev/null 2>&1; then
                for cert_path in "$ssl_dir"/*.crt; do
                    [ -e "$cert_path" ] || continue
                    if [ -L "$cert_path" ]; then
                        target=$(readlink "$cert_path")
                        case "$target" in
                            "$CERTS_DIR"/*)
                                add_service_to_update "$service_name"
                                break
                                ;;
                        esac
                    fi
                done
            fi
        done
    fi
fi

echo "-----> Requesting renewal with certbot"

CONTAINERS_TO_RESTART=()
for container in $(docker ps --format "{{.Names}}"); do
    if docker port "$container" 2>/dev/null | grep -qE ":80/"; then
        echo "       Temporarily stopping container: $container"
        docker stop "$container" > /dev/null 2>&1
        CONTAINERS_TO_RESTART+=("$container")
    fi
done

docker run --rm \
    -v "$PLUGIN_DIR:/etc/letsencrypt" \
    -v "$PLUGIN_DIR/logs:/var/log/letsencrypt" \
    -p 80:80 \
    certbot/certbot renew \
    --preferred-challenges http \
    --config-dir "/etc/letsencrypt" \
    --work-dir "/etc/letsencrypt" \
    --logs-dir "/var/log/letsencrypt" \
    --non-interactive \
    --quiet

RENEWAL_EXIT_CODE=$?

if [ ${#CONTAINERS_TO_RESTART[@]} -gt 0 ]; then
    echo "-----> Restarting temporarily stopped containers"
    for container in "${CONTAINERS_TO_RESTART[@]}"; do
        docker start "$container" > /dev/null 2>&1
    done
fi

if [ $RENEWAL_EXIT_CODE -ne 0 ]; then
    echo "-----> Certificate renewal failed"
    echo "       Check logs: $LOGS_DIR"
    exit 1
fi

if ! chmod -R u+rwX "$PLUGIN_DIR" 2>/dev/null; then
    sudo chown -R "$(whoami):$(whoami)" "$PLUGIN_DIR" 2>/dev/null || true
    chmod -R 755 "$PLUGIN_DIR" 2>/dev/null || true
fi

echo "-----> Certificates renewed successfully"

if [ ${#services_to_update[@]} -gt 0 ]; then
    echo "-----> Refreshing nginx SSL symlinks"
    for service in "${services_to_update[@]}"; do
        if [ -n "$SERVICE_FILTER" ] && [ "$service" != "$SERVICE_FILTER" ]; then
            continue
        fi
        update_symlinks_for_service "$service"
    done
else
    echo "-----> No nginx services detected for relinking"
fi

echo ""
echo "-----> Updated certificate information:"
while IFS= read -r -d '' domain_dir; do
    domain=$(basename "$domain_dir")
    fullchain="$domain_dir/fullchain.pem"
    if [ -f "$fullchain" ]; then
        if command -v openssl >/dev/null 2>&1; then
            expiry=$(openssl x509 -enddate -noout -in "$fullchain" 2>/dev/null | cut -d= -f2)
            if [ -n "$expiry" ]; then
                echo "       $domain: Expires $expiry"
            else
                echo "       $domain: Certificate renewed"
            fi
        else
            echo "       $domain: Certificate renewed"
        fi
    fi
done < <(find "$CERTS_DIR" -mindepth 1 -maxdepth 1 -type d -print0)

echo ""
echo "-----> Renewal process complete"
